/**************
Problem Link : https://leetcode.com/problems/magnetic-force-between-two-balls/   LeetCode , 1552 Magnetic Force Between Two Balls . 

******************/

import java.util.Arrays;
class Solution {
    public static boolean isPossible(int[] arr,int dist ,int m){
        int count = 1 , last = arr[0] ; // 1st always we put at 1st place
        for(int i = 0 ; i < arr.length ;i++){
            if(arr[i] - last >= dist){
                count++ ;
                last = arr[i];
              //  if(count == m) return true ;
            }
        }
        return  count >= m ; // it will return true if this condition is true otherwise false 
    }
    public int maxDistance(int[] position, int m) {
     
     
     // This Brute Foce Using Linear Search we are getting time exceeded , so optimal approach we hav to use ,that is Binary Search

        // using Linear Search we are checking 
         Arrays.sort(position);
         int maxInd = position.length - 1 , minInd = 0 ;// array sorted so 1st is mini and last is max
         int maxDis = position[maxInd] - position[minInd] ; // finding max distance possible where we reach for finding 
         for(int i = 1 ; i <= maxDis ;i++){
            if(isPossible(position,i,m)){
                continue ;
            }else return (i - 1) ; // if where that is not possible distance to fix magnet just previous one is answer 
         }
         return -1 ;
    }
}


*************/

OPTIMAL APPROACH : USING BINARY SEARCH 
import java.util.Arrays;

class Solution {
    public static boolean isPossible(int[] arr, int dist, int m) {
        int count = 1, last = arr[0]; // Place the first magnet at the first position
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] - last >= dist) {
                count++;
                last = arr[i];
                if (count == m) {
                    return true; // Found a way to place all magnets
                }
            }
        }
        return false;
    }

    public int maxDistance(int[] position, int m) {
        Arrays.sort(position);
        int minDist = 1;
        int maxDist = position[position.length - 1] - position[0];
        int result = 0;

        while (minDist <= maxDist) {
            int mid = minDist + (maxDist - minDist) / 2;
            if (isPossible(position, mid, m)) {
                result = mid; // Store the maximum distance where it's possible
                minDist = mid + 1; // Try for a larger distance
            } else {
                maxDist = mid - 1; // Try for a smaller distance
            }
        }

        return result;
    }
}


***************/
